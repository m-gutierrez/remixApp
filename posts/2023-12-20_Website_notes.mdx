---
title: Website notes
description: This is my first entry
date: 2023-12-15
permissions: PUBLIC
tags:
  - how-to
  - webdev
icon: https://lh3.googleusercontent.com/pw/AMWts8AhcLCaaBQUVAJo-k3zM4S3NiulNspH6lIocBxF_5KIEwWKx8ETiH5_tbHRMz-ZH994WASzFvW8twUVTRhNoOhPybH8FERSJuTcAY4bRttyHdAHPNJefHTtFe0CBYRAmLdR-vsh5CfBjyOrwZd74m_aBw=w3692-h2078-no
images:
  - https://lh3.googleusercontent.com/pw/ABLVV87QOK_7SUMS2n6oDTfmQDPNWx-gV3tT4zHYK5l-3gtlmKUiMbKbMkyzbP787Ya-q212t79Dzpq_u2wjq2txoDqGhVXVmAK4uUBC6bWEn832JsY4yWHBYPTN_4aOsA0rePUJKKOMm1lD4yrVf2XsGVmJqg=w1184-h2104-s-no-gm?authuser=0
  - https://lh3.googleusercontent.com/pw/AMWts8AhcLCaaBQUVAJo-k3zM4S3NiulNspH6lIocBxF_5KIEwWKx8ETiH5_tbHRMz-ZH994WASzFvW8twUVTRhNoOhPybH8FERSJuTcAY4bRttyHdAHPNJefHTtFe0CBYRAmLdR-vsh5CfBjyOrwZd74m_aBw=w3692-h2078-no
  - https://lh3.googleusercontent.com/pw/ABLVV866sCWmpfUku6HTmWwttdQntRQILPsznAYL5u9S1CWmBdp1pzW9u47IEXTzi1uLTjfNQkx7eEflZnPpVFIbiaoDto2egMHEkZtrW_XJ2tLYF4W94OO8jyEk1_bR2xPBXyo1-4oGWdPlvJnSwVBeDGw6og=w2024-h1138-s-no-gm?authuser=0
  - https://lh3.googleusercontent.com/pw/AMWts8Bx2iWHOIhdECCtwMRD86tBZOrm0MAhnVqdX_btgQ7cB6ciu-x1YBqg-5VCSUsMa5AVhz_CoNBwcE1WPZ6H41GxQnowFJp8dZ1acQumpV2H5Rcz5imtqOdnUPKTQ1G49k4yKuFuL3arokAUJ-d_mEEmoA=w1202-h2136-no
  - https://lh3.googleusercontent.com/pw/ABLVV87WNNMm4CU2-NQ2AxW4cwAr3IYKkYNUmSZl4VkMrpywhZ_4KI29mwe9KdPM2yNW0yBMd_Ivpw5lSrrdyJ4RjRnwqxQC7D8wBwvnty3x98_agbJm2jj55497RtSBHeXgj8Gw1xAjCGbJiugA2nRqxffp2Q=w1366-h2048-s-no-gm?authuser=0
  - https://lh3.googleusercontent.com/pw/ABLVV84Qky0o7mgc-YvA7cPlYXVB9kgHK-pmwb_-yu_fe3b90oe9bQipYXVLBIMeFQxAmGCH1bbh-zuM_PnyVCwQP__cNPiXPDvlduKbZjKnRZ4PGRLvsEoxs2EacTv88XM7qA5Yp5O7YEXz_Qc2r8CbjNLPkg=w2024-h1138-s-no-gm?authuser=0

recipe:
    ingredients:
      - - flour, all purpose
        - 500g
      - - baking soda
        - 1 teaspoon
      - - baking powder
        - 1/2 teaspon
      - - eggs, large
        - 4
      - - Butter (salted)
        - 20 tablespoons (300g)
      - - Dark brown sugar
        - 340g
      - - Granulated sugar
        - 225g
      - - Vanilla
        - 4 teaspoons
      - - Walnuts
        - 310g
      - - Semisweet Chocolate chips
        - 310g
    preperation:
      - Preheat Oven to 375F
      - In separate bowl, add dry ingredients, flour, baking soda, baking powder
      - In mixing bowl, add sugar and vanilla
      - Butter- Cut 4 tablespoons into 1cm cubes and set aside
      - Butter- Brown 8 tablespoons in a small/medium pan over medium heat
      - Butter- melt remaining 8 tablespoons into brown butter pan after removing from heat.
      - add browned + melted butter into mixing bowl.
      - Add eggs, one egg at a time making sure to break the yolk. Whisk for 30-60s, let rest for 3min and repeat 3 times. 
      - Add flour mixture to mixing bowl and slowly add cubbed butter while mixing. Mix until you have a creamy dough consistency (1-3min)
      - Add chocolate chips and walnuts, mix until evening distributed (~30s)
      - On a baking tray lined with parchment paper, add ~1/4 cup (1 ice cream scoup) of cookie dough w/ 1-2in of spacing around each. On a baking tray lined with parchment paper, add ~1/4 cup (1 ice cream scoup) of cookie dough w/ 1-2in of spacing around each. On a baking tray lined with parchment paper, add ~1/4 cup (1 ice cream scoup) of cookie dough w/ 1-2in of spacing around each.
      - Bake for ~10min or until edges have just started to set. Remove from oven and let cookies rest on baking tray for ~5min before removing from tray.


    images:
      image1:
        google_url: https://lh3.googleusercontent.com/pw/ABLVV853h6OjHHY1fkWhYu_b4pZGcFhJgeIV5zzTVT5_pXXhJahlf-IcpIUVbh7QLo7iFEUdzSDmBLuUDtemsrCcAkqmpumHUjdrMRvBM2rYh4hOCV-NmSAsC75RX97Xgzx9oDQa8KjdXEitu3_K0Uljci2oFw=w2024-h1138-s-no-gm?authuser=0
        title: Cookie dough
        description: ''
      image2:
        google_url: https://lh3.googleusercontent.com/pw/ABLVV866sCWmpfUku6HTmWwttdQntRQILPsznAYL5u9S1CWmBdp1pzW9u47IEXTzi1uLTjfNQkx7eEflZnPpVFIbiaoDto2egMHEkZtrW_XJ2tLYF4W94OO8jyEk1_bR2xPBXyo1-4oGWdPlvJnSwVBeDGw6og=w2024-h1138-s-no-gm?authuser=0
        title: Cookie batch
        description: ''
      image3:
        google_url: https://lh3.googleusercontent.com/pw/ABLVV84Qky0o7mgc-YvA7cPlYXVB9kgHK-pmwb_-yu_fe3b90oe9bQipYXVLBIMeFQxAmGCH1bbh-zuM_PnyVCwQP__cNPiXPDvlduKbZjKnRZ4PGRLvsEoxs2EacTv88XM7qA5Yp5O7YEXz_Qc2r8CbjNLPkg=w2024-h1138-s-no-gm?authuser=0
        title: Cookie
        description: ''

---

# WARNING

Although this is written as a tutorial it is not. These are flow-of-thought notes that I am hoping will serve as a reference to myself the next time I have to do something similar. This is my first interaction with remix and react syntax so please don't waste too much time here. That said please feel free to ask for clarification as to why something is working.

# Introduction


Stay at home parenting is fun, and time consuming, but I miss technical writting and note keeping. I haven't done any kind of web development for a long time and thought it'd be a good exercise to build something from scratch and see what tools are available these days. Aside from that I have a couple back-of-my-mind ideas for what I'd use this skill for. 

    1. General note keeping and organization. It's amazing how much there is to keep track of in having a household. Documenting kids schedules and routes, medical notes and interpreting them, home maintenence with schedules and documentation, recipes! my god cooking is a million percent easier and less mentally draining if you have a recipe you trust.
    2. GAMES! There are a few party games I've really liked playing that would be better with a virtual setup instead of a physical board. Like custom code-name prompts or games with a drawing component.
    3. UI for machinery, I want to be able to put together a half-decent ui for reading and controlling various connected hardware (motors, cameras, sensors), professionally this has always fallen low enough on the priority queue relative to function that it simply never gets done. I'd like to have a framework in mind to put something like this together as a quick convience.  


I've had a running blog that I mostly keep private for note taking, mostly an easy way to make markdown notes a little more readable but this has been on static site generators like jekyll and don't naturally offer a back-end integration pathway that I'd want for a gaming engine or UI for physical hardware. 

# Useful guides and tutorials

 I initially started this project thinking flask would be the best fit for me, I usually program in python when I have a choice and especially when thinking of hardware control python is where I have the most knowledge and experience with device api's. 

 - This series by [Miguel Grinberg](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world) was especially helpful as one of the more complete getting started guides I found. It's helpful to have one person explaining things from hello-world through databases and all the way to deploying. It provides enough context to let you know when this is 'a way' to do this versus this is 'the way' to do this, which can be hard to decipher on alot of guides and sometimes makes it hard to extrapolate on. 

After completing the guide, adding user login's a recreating my previous jekyll site I realized this isn't what I was really looking for. A good deal of what I want in the end has both server and client side interactions, server side for keeping a game or hardware state, rendering complex-data and client side things like drawing canvas', changes in button states, or interactions with graphical data. Flask works great for providing a backend api and seems like a great way to connect web-to-python but doesn't seem like a great way to build a front-end. 

Where I ended up for now is a react frontend with a supporting server, which can then connect to a flask api if needed. 

 - [Miguel Grinberg](https://blog.miguelgrinberg.com/post/introducing-the-react-mega-tutorial) had a nice tutorial for this as well. Note the flask api used in this tutorial makes more sense if you first complete his flask tutorial (although not identical to whats used in the react tutorial). 

I decided to use [remix](https://remix.run/) 


# Example features

Before going over some of the implementation details, here are a few feaures I thought necessary to have a 'functional' site.

## markdown blog posts with dynamic content

I like keeping notes in markdown, its easy to write, decent to read unrendered, and there are a ton of parsing packages to handle most rendering you'd want. 


## Syntax highlighting

A good deal of 
Flask-flatpages uses python-pygments to render code snippets, this page uses 'monokai' styling, other options can be on the [pygments styling page](https://pygments.org/styles/)

```python
    # Testing code highlighting
    x = a + b
    print('This is a python string')
    def alpha(ball=None):
      """ This is a doc string
      """
      if ball is None:
        return('cat')
      else:
        return(f'this is a {ball}')
    def balloon(y):
      return( y**2)

    print(alpha('dog'))
    print('done', ballon(10))
```

## Math rendering

This is a bit of a nostalgia add at this point, I don't write much math any more but I'm still holding onto it and think its a requirement for proper documentation. 

```math
\psi = \int_0^\infty e^{-\frac{x^2}{2\sigma} }d\Omega 
```

and in line rendering $$\forall\ \phi_0\ \exists\ \alpha\ \ni\ \beta \neq 0$$ that works with double \$\$ ...\$\$ or syntax highlighting with a 'math' tag. Rendering is done with a combination of [remark-math](https://github.com/remarkjs/remark-math) and [rehype-mathjax](https://github.com/remarkjs/remark-math/tree/main/packages/rehype-mathjax)

## Extensible and dynamic content

Markdown usually falls short if you suddenly want some dynamic content. In the past this has led me to keep notes in things like colab or jupyter notebook, which isn't quiet the write place for a lot of notes. So either you keep notes in multiple places, link to majority jupyter content or just describe what is in the jupyter notebook and link some images of graphs or something. The [mdxjs](https://mdxjs.com/) library seems like a good solution to this problem and allows you to add arbitrary javascript directly into your markdown posts


Like this photo gallery using [react-photo-album](https://react-photo-album.com/) and [yet-another-react-lightbox](https://yet-another-react-lightbox.com/) to provide a click-through gallery

import Gallery from "utils/gallery";

<Gallery photos={frontmatter.images} />

included in markdown via: 

```jsx
  import Gallery from "utils/gallery";

  <Gallery photos={frontmatter.images} />

```

## User authentication and comments

Similar to math rendering, comments are really not needed, but I wanted user-authentication for a couple things and comments just pop up in all the tutorials. One reason for authentication is to allow for private or privileged posts. I am a foster parent and some things I want to document or memorialize may be sensitive and only to be shared with family or close friends. Aside from that both ui and game elements would require some kind of user identification. 
I opted for OAuth based SSO instead of storing any user-names and passwords myself because why would anyone want to manage usernames and passwords.


# Development

After settling on wanting to explore [reactjs](https://react.dev/) I had to make some choices on a framework, and libraries I should use. For no good reason, other than some half-hearted review reading, I decided to use [remix](https://remix.run/) for stack development, [mdx](https://mdxjs.com/) for markdown rendering that allows for in-line jsx content (like the image gallery above), [mdx-bundler](https://github.com/kentcdodds/mdx-bundler) for server-side rendering and live compiling from raw mdx files, and [react-bootstrap](https://react-bootstrap.netlify.app/) for site layout and styling. I have used bootstrap for some previous work and liked the class name driven styling, keeping most or all of the styling with the html (or jsx) content. I'm not sure I understand why this isn't the default solution or what problem newer libraries like [styled-components](https://styled-components.com/)


## Getting started

To get started we start a new project using the create-remix npm library, we'll call it remixApp

```bash
  npm create remix@latest remixApp
```

This will create a project directory with the base dependencies for remix and some default configurations set. It will also make the directory a git repository. Running 

```bash
  npm run dev
```
 will result in the following default page being served on http://localhost:3000. 

![](https://lh3.googleusercontent.com/pw/ABLVV840Vs_4svodO-fu-1wypuEiSJuusPvIUJzBXQPDbwXIx_w-zYEOxWxo0WYF0wGuJ-0LJrzm0plics5_4f7IaB7qkfFJnqJ6nZ0psaY-QUzxFXQ2Bh4kVtq82OGvnSvizg6CQQbZVbIYcMdAIC7IFHD31g=w300)

### Setting up github repo

We'll want to track this project in github, you're free to do this at any stage but we might as well track changes from the start. Create a new repository in your github dashboard remixApp, then add+push the current directory via

```
  git remote add origin git@github.com:[GITHUBACCT]/remixApp.git
  git branch -M main
  git push -u origin main
```

The rough organization we're going to aim for is
  - remixApp
    - app
      - layouts : Contains common page layouts and formatting
        - Page
        - Body
        - Header
        - Sidebar
        - Comments
      - utils : Contains utility functions, server/client
        -  helpers
      - routes : Contains the routes for the page
        - auth.login 
        - auth.logout 
        - auth.callback
        - _index : home page
        - $post.tsx : routes for blog posts
        - denied.tsx : redirect for bad permissions
        - test.tsx : we'll test layout and things here
    - posts : blog posts
      - 2023-12-01_Hello_World!.mdx
      - ...
    - prisma : database schema and migrations

## Design layout

I'm partial to a pretty simple site layout. A top header with primary navigation links, a sidebar for page-specific meta content (comments, wiki-trees, similar content links etc), and a Main content area that houses everything else. 

<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vRRkz5NMhHhb8fsTNyU03XMvfFQ-47RqGpzPqY1pSa5cG6-IGxQHecco5BYwvAnRavJvSKCC4jemhMv/embed?start=false&loop=true&delayms=3000" frameBorder="0" width="480" height="299" allowFullScreen={true} mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>

To start with our layout we'll want to install [react-bootstrap](https://react-bootstrap.netlify.app/) and bootstrap css. 

```
  npm install react-bootstrap bootstrap
```

Then lets update our root.tsx file to include the boostrap style stylesheet, and you should see a immediate change in the default rendered page.

```tsx
// app/root.tsx
import bootstrapCSS from "bootstrap/dist/css/bootstrap.min.css";
import type { LinksFunction } from "@remix-run/node";
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

export const links: LinksFunction = () => [
  ...(bootstrapCSS ? [{ rel: "stylesheet", href: bootstrapCSS }] : []),
];

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}

```


### Creating a header

Before we create a header for the page lets update our tsconfig.json file to add 'app' to the baseURL key. This will allow us to use imports relative to the 'app' directory. 


```
// remixApp/tsconfig.json
{
  "include": ["remix.env.d.ts", "**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "isolatedModules": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "target": "ES2022",
    "strict": true,
    "allowJs": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": "app",
    "paths": {
      "~/*": ["./app/*"]
    },

    // Remix takes care of building everything
    // in `remix build`.
    "noEmit": true
  }
}
```

Now, create a new directory and file under app, app/layouts/header.tsx and start by creating a new component. 

```
export default function Header() {
  return(
    <>
    HEADER!!! 
    </>
    )
}
```

and importing this into our default route \_index.tsx

```tsx
// app/routes/_index.tsx
import type { MetaFunction } from "@remix-run/node";
import Header from 'layouts/header';


export const meta: MetaFunction = () => {
  return [
    { title: "New Remix App" },
    { name: "description", content: "Welcome to Remix!" },
  ];
};

export default function Index() {
  return (
    <div style={{ fontFamily: "system-ui, sans-serif", lineHeight: "1.8" }}>
      <Header />
      <h1>Welcome to Remix</h1>
      <ul>
        <li>
          <a
            target="_blank"
            href="https://remix.run/tutorials/blog"
            rel="noreferrer"
          >
            15m Quickstart Blog Tutorial
          </a>
        </li>
        <li>
          <a
            target="_blank"
            href="https://remix.run/tutorials/jokes"
            rel="noreferrer"
          >
            Deep Dive Jokes App Tutorial
          </a>
        </li>
        <li>
          <a target="_blank" href="https://remix.run/docs" rel="noreferrer">
            Remix Docs
          </a>
        </li>
      </ul>
    </div>
  );
}
```

Bootstrap offers components for most everything you'd want to do with decent default styling. In the case of our header, check out the [Navbar](https://react-bootstrap.netlify.app/docs/components/navbar) component and the examples provided. There are some nice features we'd like to include in our header, namely
  1. left-justified brand image/text
  2. right-justified navigation buttons
  3. responsive layout, collapsing on smaller screen formats. 
  4. we'd like the header to always be visible. 

```tsx
// app/layouts/header.tsx
import { Navbar, Nav, Container } from 'react-bootstrap';
import { NavLink} from "@remix-run/react";


export function CollapsingNav() {
    return (
      <Navbar.Collapse id="basic-navbar-nav" className="justify-content-end">
        <Nav defaultActiveKey="/" 
        className="justify-content-end">
          <Nav.Link as={NavLink} to="/">Home</Nav.Link>
          <Nav.Link as={NavLink} to="/about">About</Nav.Link>
          <Nav.Link as={NavLink} to="/login">login</Nav.Link>
        </Nav>
      </Navbar.Collapse>
    );
}


export default function Header() {
  return (
    <Navbar expand='md' bg="dark" data-bs-theme="dark"
      className="Header bg-body-secondary py-0 px-3 mb-2 sticky-top">
        <Navbar.Brand className="Header">MG</Navbar.Brand>
        <Navbar.Toggle aira-controls="basic-navbar-nav" />
        <CollapsingNav />
    </Navbar>
  );
}
```

some notes about the attributes or props used for each of the components. Bootstrap works in a lot of ways like a inline-styled component, e.g. we'll try to avoid css modifications where a bootstrap option exists. On top of that bootstrap has a lot of common js features built in, such as a responsive collapsible header (if you resize your browser window you'll notice that eventually the navigation links collapse into a trigram dropdown menu). This transition or break-point is set with the expand='md' attribute, these can be user defined but the [bootstrap defaults](https://getbootstrap.com/docs/5.0/layout/breakpoints/) are already sensible. Next, are self explanatory, setting the background dark, and the header theme to a dark style. Most of the nice bootstrap features comes in adding class names. 
  - Header : This has no bootstrap function, its just our own label that'll let us add additional css later if necessary.
  - bg-body-secondary : Modifies [bootstraps background color](https://getbootstrap.com/docs/5.0/utilities/background/) to be a light gray instead of near-black. 
  - px-3 : Sets the x-axis padding to '3', See [bootstraps spacing](https://getbootstrap.com/docs/5.0/utilities/spacing/) for details
  - mb-2 : Sets the bottom margin to '2', This is just planning head to make sure the body content has an offset from the header. [bootstraps spacing](https://getbootstrap.com/docs/5.0/utilities/spacing/) for details
  - sticky-top : This makes the header always visible regardless of scroll state of the page, it'll follow and stay at the time of the view window as you scroll down. 

Next we have a Navbar.Toggle w/ aria-controls set to the id of the nav elements we want to collapse, e.g. "Navbar.Collapse id=aira_control_target". And lastly, An additional component this the header time "CollapsingNav" has been separated out for clarity, this isn't necessary yet but I separated it out now because I think I'll want to add additional logic to the navigation depending on user-state. Within CollapsingNav, we again have bootstrapped styled components with "justify-content-end", again self-explanatory, justifying the content to the end of the container giving us our right-justified nav links, see [bootstraps flex elements](https://getbootstrap.com/docs/5.0/utilities/flex/) for more details. Lastly, A quirk relative to the bootstrap navbar examples is the presence of the 'as=\{NavLink\}' option, This is a [remix component](https://remix.run/docs/en/main/components/nav-link) wraps reacts Link w/ some nice functionality for how remix handles routes.

### Creating the body containers

As shown in our 3 box mockup, What I'd like to see in the end is a top header with two asymmetric 'body' boxes under it supporting our main content, and a sidebar for meta/sidecar data related to our content.

First, lets make a breaking change in the our \_index.tsx route to reflect the layout we want. 

```tsx
// app/layouts/_index.tsx
...
export default function Index() {
  return (
    <Container fluid className='d-flex flex-column 
      m-0 px-0 bg-secondary bg-gradient vh-100'>      
      <Header />
      <Body 
        main={<>BODY!!!!</>} 
        sidebar= {<> SIDEBAR!!!!!!</>}
      />
    </Container>
  );
}
```
We want an overall container that fills the viewport horizontally and vertically, that will stack elements within in vertically (header on top of a body) within this we want a header we already created, and a body that will have two sections, main-content and sidebar-content. The bootstrap classes added here are 
  - [fluid](https://getbootstrap.com/docs/5.0/layout/containers/) : fill 100% of the viewport at all break points
  - [d-flex](https://getbootstrap.com/docs/5.0/utilities/flex/) : makes container a flex-display
  - flex-column : sets the flex-direction to vertical (header on top of body)
  - m-0 : bootstrap adds some default margins but we want to remove that since this is the container for our entire page (and we want the header to go all the way to the edge)
  - bg-secondary : alters the background color to a light grey. 
  - [vh-100](https://getbootstrap.com/docs/5.0/utilities/sizing/) : makes the container fill the entire view window. 

With that in place we can move onto our body layout, which will accept two children components, main-content and sidebar-content.


```tsx
// app/layouts/body.tsx
import { Row, Col, Stack} from 'react-bootstrap';

export default function Body({ main, sidebar }) {
  return (
      <Row className="Content align-items-stretch 
      justify-content-center mx-1 flex-grow-1 mb-2"
      style={{minHeight:0,}}>
        <Col sm={12} md={8} 
        className="MainContent border rounded
        bg-body-secondary mx-2 overflow-auto h-100">
          <Stack>
            <div>
              {main}
            </div>
            <div className="d-sm-block d-md-none">
              {sidebar}
            </div>
          </Stack>
        </Col>
        <Col md={3} className="Sidebar border rounded 
        bg-body-secondary d-md-block d-none overflow-auto h-100">
          {sidebar}
        </Col>
      </Row>
  )
}
```

The classNames perform the following functions.
  - Row className=
    - Content : Our class name in case we want to add our own css later
    - [align-items-stretch](https://getbootstrap.com/docs/5.0/utilities/flex/) : This forces items within this component to stretch to align their vertical start / end positions. We want two equal height columns.
    - justify-content-center : We want the main and sidebar content to be centered on the page (equal left/right margins)
    - mx-1 : This is an aesthetic choice, when the content fills the screen (12 on small screens) I'd like the box to have a sliver of background visible around the box, to frame the content still. otherwise this has little effect on the two column layout since we are already allowing 1 segment to float (12 - 8 - 3=1). 
    - flex-grow-1 : fill the available height (inherit from the flex-column above for grow direction)
    - mb-2 : Allow some margin on the bottom of the page, again this is just to frame the content area. 
    - style : I don't understand why this is necessary but something with flex and overflow doesn't work unless there is a min-height setting, and bootstrap doesn't offer a class attribute for this. 
  - Col className=
    - [border](https://getbootstrap.com/docs/5.3/utilities/borders/): add a border to the container 
    - rounded : round the border corners
    - mx-2 : Add x-axis margin to separate the sidebar and main content containers
    - [overflow-auto](https://getbootstrap.com/docs/5.0/utilities/overflow/) : allow the box to overflow. This allows the page layout to stay fixed regardless of what is put into the main and sidebar areas. It also allows the sidebar and main areas to scroll independently. 


A lot more happening here. For the body / sidebar construction we're using bootstraps grid layout (Row, Col) which is based on 12 equal segements. An overall row is defined and under it two columns, which on a medium screen 'md' (or larger) creates a 8-segement wide mainContent area and a 3-segment side sidebar (1 segement left empty to allow for additional margins). On a small screen (sm) (or smaller) we want the mainContent to fill the entire screen because there's nothing worse than having to zoom in / scroll around content on a phone. The inner stack is to allow the the sidebar content to move into the main content area for small screens.

### Creating a page container

Now that we have \_index.tsx looking how we want we'll create one more top-level layout so that our index and all subsequent routes will be nice a simple. 

```tsx
// app/routes/_index.tsx
...
export default function Index() {
  return (
    <Page 
      main={<>BODY!!!!</>} 
      sidebar= {<> SIDEBAR!!!!!!</>}
    />
  );
}

```

Where the page Component just the previous \_index.tsx layout. 


## Creating a feed route

Next, we're going to create our home page which will also be the feed for posts we've made in the past. To start out with we'll make a few dummy blog posts, from past sites I've worked with I want a few particular items visible in a feed. 
  1. A post title
  2. A post date
  3. An image
  4. A list of tags that categorize the post.  


We're going to use [mdx](https://mdxjs.com/guides/) for our posts ([This was a helpful reference](https://blacksheepcode.com/posts/adding_msw_bundler_to_remix_app) in getting started, so we should include the meta data we want on our feed in the frontmatter of each post. Lets create a new directory and posts/
  - posts/
    - test1.mdx
    - test2.mdx
    - test3.mdx

With their content 

```
// posts/test1.mdx
---
title: Happy days
date: 2018-06-01
tags:
 - mountains
 - cooking
post_image: https://lh3.googleusercontent.com/pw/AMWts8BsEQQkGIthtVx7yVCLX-7xSDk5KgbblNZnmopy03jLgvSZ_hTFj-9GjZpNiVnAF3OI_GhIlakCqs8KTVYNTMvyBXrOalZ51eYaZ4qPADFBacaMQSD9nXSmii6RSzhhDbyZfDhP5ZJDSYmTbmUyNd39Bg=w3692-h2078-no

---

This is my **first** post!! Welcome!!
```

Maybe change the frontmatter a bit for each. We're going to need a few server side utilities for this next part. First we're going to need a new package to help parse the front-matter from our files. Note this is also done in the mdx build process but we want our feed to exist before we've built any mdx files. We'll use the [front-matter](https://www.npmjs.com/package/front-matter) package for this 

```
  npm install front-matter
```

Next, we'll create a server side utility for file access, note, remix automatically tries to separate client and sever side elements but you can force it by [including the .server](https://remix.run/docs/en/main/file-conventions/-server) in the file name. In this file we'll want to get a list of meta data for each post in our posts/ folder.

```tsx
// app/utils/fs.server.tsx
import { readFile, readdir } from "fs/promises";
export { readFile, readdir } 
import path from "path";
import parseFrontMatter from "front-matter";

export function get_post_path(post_slug : string){
  const post_path = path.join(
    process.cwd(), 'posts', (post_slug ? post_slug : ''));
  return post_path;
}

export async function ls_posts(){
  const filePath = get_post_path('');

  const post_paths = await readdir(filePath, {
    withFileTypes: true,
  });

  return post_paths
}

export async function get_frontmatter(post_path){
  const file = await readFile(post_path);
  const { attributes } = parseFrontMatter(file.toString());

  // check for requried fields or assign defaults
  attributes.title ??= "PLEASE ADD A TITLE";
  attributes.date ??= "1010-10-10";
  attributes.tags ??= ["untagged"];
  attributes.icon ??= "https://lh3.googleusercontent.com/pw/ABLVV8721vqwvEeiu-5WIyinQUSbO1QzJP2XlmDO2YcDQZ9hNW0fIW6GYxi1r8RG4KAi-EM-0vPQRcR07CshImZNOftitftjlfsE_-j37BkqaoWmSDN2QDvw3NjV_aImHYucgiOl0JXBp6SCr9hYidWl42z07Q=w1704-h1704";

  // replace image dimensions with width of 100px
  attributes.icon = attributes.icon.replace(/=w\d{1,5}-h\d{1,5}/, "=w100")
  // Convert date to date datestring
  attributes.date = (new Date(attributes.date)).toLocaleString(
              'en-CA', { hour12: false, timezone: "UTC", 
              dateStyle: "short", timeStyle: "short"});

  return attributes;
}

export async function get_sorted_posts_meta(){
  // Get a list of meta data for posts, sorted by date
  const post_paths = await ls_posts();


  const posts = await Promise.all(
    post_paths.map( async (dirent) => {

    const post_path = path.join(dirent.path, dirent.name);

    const attributes = await get_frontmatter(post_path);//parseFrontMatter(file.toString());
    return {
      slug: path.parse(dirent.name).name,
      attributes: attributes,
      };
    })
  );

  return posts.sort(function(a,b){
    return (new Date(b.attributes.date) - new Date(a.attributes.date));
  });
}
```
Now we can update our \_index.tsx route to format the meta data into feed entries. 

```tsx
// app/routes/_index.tsx
import type { MetaFunction } from "@remix-run/node";
import { NavLink, useLoaderData } from "@remix-run/react";
import { Stack, Container, Nav} from "react-bootstrap";

import Page from "layouts/page";
import { get_sorted_posts_meta } from "utils/fs.server";


export const meta: MetaFunction = () => {
  return [
    { title: "Remix" },
    { name: "description", content: "Feed" },
  ];
};

export let loader = async () => {
  const posts = await get_sorted_posts_meta();
  return posts ;
};


export function Main({ posts }) {
  return (
    <>
      <Stack gap={3} className="mt-1">
        { posts.map( (post) => (
            <FeedItem key={post.slug} post={post}/>
          ))
        }
      </Stack>
    </>
  );
}

export function FeedItem({ post }) {
  return (
    <Container key={post.slug} 
      className="px-0 border border-dark rounded pt-1">
      <Nav.Link as={NavLink} to={post.slug} 
        className="text-primary fs-3 mb-1">
        <img className="mx-2 rounded" 
          src={post.attributes.icon} 
          referrerPolicy="no-referrer"/>
        {post.attributes.title}
      </Nav.Link>
      <hr className="my-0"/>
      <Stack direction="horizontal">
        <div className="text-start ms-1">
          {post.attributes.tags.map( (tag) => (
            <span key={post.slug+tag}>
              <small><small>{tag} </small></small>
            </span>
            ))}
        </div>
        <div className="ms-auto me-1 small">
          <small><small> {post.attributes.date}</small></small>
        </div>
      </Stack>
    </Container>
  );
}

export default function Home() {
  const posts = useLoaderData();
  return (
    <Page 
      sidebar={<>SIDEBAR!!!!</>} 
      main={<Main posts={posts}/>}
    />
  );
}
```

We use use [useLoaderData/Loader](https://reactrouter.com/en/main/hooks/use-loader-data) to gather posts metadata on the loading of the page. And two new components to compose the 'main' section of the page. The top level component 'MAIN' loops over each post and generates a 'FeedItem' for each. The nice feature here is that the post page is dynamically created on load, so we can create new posts and have them appear immediately in the feed without needing to re-build anything. 

## Creating a post page

Similarly, We want our posts to render onload. For a low traffic site this is fine, but it's still pretty wasteful to re-build the page every load. The benefit is that deploying changes is just pulling the latest posts with no need to rebuild. Later on what I think I'd like is an admin route with a re-build option or some way to toggle between building and saving posts vs building live. For now though, always rebuilding the mdx posts is what we'll do. For this we'll be using [mdx-bundler](https://github.com/kentcdodds/mdx-bundler) to bundle and compile the mdx posts, this allows us to import and use components in an mdx post without needing a separate reference in the server side code, this makes the blog posts function as independently as possible. 

```tsx
// app/utils/mdx.server.tsx
import { bundleMDX } from "mdx-bundler";
import { readFile, get_post_path } from "utils/fs.server";
import path from "path";

import rehypeHighlight from "rehype-highlight";
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import rehypeSlug from 'rehype-slug';
import rehypeToc from "rehype-toc";
import rehypeMathJax from 'rehype-mathjax';

import remarkFrontmatter from 'remark-frontmatter';
import remarkMdxFrontmatter from 'remark-mdx-frontmatter';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';


export async function getPost(slug: string) {
  const source = await readFile(
    get_post_path(slug+'.mdx'),"utf-8");

  const post = await bundleMDX({
    source,
    cwd: path.join(process.cwd(), 'app'),
    mdxOptions(options, frontmatter){
      options.remarkPlugins = [
        ...(options.remarkPlugins ?? []),
        remarkFrontmatter,
        remarkMdxFrontmatter,
        remarkGfm,
        remarkMath,
      ];
      options.rehypePlugins = [
        ...(options.rehypePlugins ?? []),
        rehypeSlug,
        rehypeToc,
        rehypeAutolinkHeadings,
        rehypeMathJax,
        [rehypeHighlight, {detect: true}],
      ];

      return options;
    },
  }).catch((error: unknown) => {
    console.error(error);
    throw error;
  });

  return post;
}
```

There's a lot of new packages here, You can remove most of them without issue depending on what you use regularly. Here's what we'll need for the above to work
  - mdx : required for compilation
  - mdx-bundler : required for bundling components imported in your mdx files.
  - esbuild : the bundler that mdx-bundler uses.
  - [remark-frontmatter](https://github.com/remarkjs/remark-frontmatter) : required for remark-mdx-frontmatter
  - [remark-mdx-Frontmatter](https://github.com/remcohaszing/remark-mdx-frontmatter) : parses and extracts mdx frontmatter
  - [remark-gfm](https://github.com/remarkjs/remark-gfm) : allows github flavored markdown. 
  - [remarkMath](https://github.com/remarkjs/remark-math) : required for rehype-mathjax
  - [rehype-slug](https://github.com/rehypejs/rehype-slug) : required by rehype-autolink-headings
  - [rehype-toc](https://github.com/JS-DevTools/rehype-toc) : creates a table of contents based on headings
  - [rehype-autolink-headings](https://github.com/rehypejs/rehype-autolink-headings) : automatically creates links to headings.
  - [rehype-mathjax](https://github.com/remarkjs/remark-math) : generates mathjax from math on page. 
  - [rehype-highlight](https://github.com/rehypejs/rehype-highlight) : adds syntax highlighting for code blocks. 

Aside from that this is just one call to bundleMDX, where the format is described in [mdx-bundlers readme](https://github.com/kentcdodds/mdx-bundler). This will be used in a new route app/route/$post.tsx, which uses [remix' dynamic route segments](https://remix.run/docs/en/main/file-conventions/routes) to match a post-slug, the post file name, to initiate the post. 

```tsx
// app/route/$post.tsx
import type { MetaFunction } from "@remix-run/node";
import {  useLoaderData, LoaderFunction } from "@remix-run/react";
import { useMemo } from 'react';
import Page from 'layouts/page';

import { getPost } from "utils/mdx.server";
import { getMDXComponent } from "mdx-bundler/client/index.js";
import { ClientOnly } from "remix-utils/client-only";


export const meta: MetaFunction = ({params}) => {
  return [
    { title: params.postname },
    { name: "description", content: "Welcome to Remix!" },
  ];
};

export const loader: LoaderFunction = async ({ params }) => {
  const slug = params.post;

  const post = await getPost(slug);
  if (post){
    const { frontmatter, code } = post;
    return { frontmatter, code };
  } else {
    throw new Response("Not Found", { status: 404 });
  }
}


export default function Blog() {
  const { frontmatter, code } = useLoaderData();
  const Content = useMemo(() => getMDXComponent(code), [code]);

  return (
      <Page 
        sidebar={<>SIDEBAR!!</>} 
        main={    
          <>
            <h1 className="display-3 row justify-content-center">
              {frontmatter.title}
            </h1>
            <ClientOnly>
             {() =>  <Content/> }
            </ClientOnly>
          </>
        }
      />
  );
}
```

Similar to our feed page, we'll use a loader to build the mdx file, from there we generate the Content is taken straight from [mdx-bundler's readme](https://github.com/kentcdodds/mdx-bundler) including the addition of useMemo to avoid reloading the page unless code changes, this will be relevant once we have a comment element in the sidebar. Lastly, we added one more package to our build, we're using ClientOnly from [remix-utils](https://github.com/sergiodxa/remix-utils) to avoid abunch of complains about hydration errors due to mathjax rendering only on the client. There may be a better way to deal with this but I don't know what it would be.  

## Adding a comment section

For this feature we'll want to add user-login function to identify comments with a username, as well as discourage spam comments. We'll need a database or someway to store comments and associate them with specific posts. And we'll need a new component to reader comments in the sidebar.

### User authentication 

In order avoid storing user names, passwords and providing a method to register new users we'll use social network authentication that is now common on most sites. Most people have a facebook, or gmail, or github account etc, so why not let these larger appliations manage user security when all we want is a username to associate with comments. To do this we'll use [remix-auth](https://github.com/sergiodxa/remix-auth) and [remix-auth-socials](https://github.com/TheRealFlyingCoder/remix-auth-socials) and follow the readme's 'how to use' instructions. The first step is to choose how we want to store a users credentials to utilize them across our site. We'll use remix's [createCookieSessionStorage](https://remix.run/docs/en/main/utils/sessions) 

```tsx
// app/utils/session.server.tsx
import { createCookieSessionStorage, redirect } from "@remix-run/node";

export const sessionStorage = createCookieSessionStorage({
  cookie: {
    name: "_session", // name of the session
    sameSite: "lax",
    path: "/", 
    httpOnly: true, 
    secrets: process.env.SessionSecret,
    secure: true,
  },
});

export async function logout(request: Request) {
  const session = await getSession(request);
  return redirect("/", {
    headers: {
      "Set-Cookie": await sessionStorage.destroySession(session)
    },
  });
}
```

Here we create a cookie session storage object with some default parameters, note a secret is stored in a remixApp/.env file where we'll store some other secrets and configuration parameters later on. Lastly, we include a logout helper that will destroy the current \_session cookie.

The next step is to create the server side logical that will handle the authentication hand-shaking, this is done with remix-auth which accepts a storage object to maintain the authentication across our site. 

```tsx
// app/server/auth.server.ts
import { Authenticator } from "remix-auth";
import { GoogleStrategy, FacebookStrategy, SocialsProvider } from "remix-auth-socials";
import { sessionStorage } from "utils/session.server";

// Create an instance of the authenticator
export let authenticator = new Authenticator(sessionStorage, { sessionKey: '_session' });
// You may specify a <User> type which the strategies will return (this will be stored in the session)
// export let authenticator = new Authenticator<User>(sessionStorage, { sessionKey: '_session' });

const getCallback = (provider: SocialsProvider) => {
  return `http://localhost:3000/auth/${provider}/callback`
} 

authenticator.use(new GoogleStrategy(
  {
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: getCallback(SocialsProvider.GOOGLE)
  },
  async ({ profile }) => {
    // here you would find or create a user in your database
    return profile;
  }
));

authenticator.use(new FacebookStrategy(
  {
    clientID: "YOUR_CLIENT_ID",
    clientSecret: "YOUR_CLIENT_SECRET",
    callbackURL: getCallback(SocialsProvider.FACEBOOK)
  },
  async ({ profile }) => {}
));
```

This is taken straight from the github readme for [remix-auth](https://github.com/sergiodxa/remix-auth). Note that for each social login you will need to get credentials from the provider for your site. This is done through a developer console, such as [console.cloud.google.com](https://console.cloud.google.com/apis/credentials).

Now we're ready to add routes that handle the login requests and the authentication callbacks. Let's start with a route that will start the user' process. We'll use [remix forms](https://remix.run/docs/en/main/components/form) to handle the routing. When a form is submited remix routes tot he listed action with form data as params. We don't need any form data here, just something to initiate the routing so we'll have single button for each social provider. 

```tsx
// app/routes/auth.login.tsx
import type { MetaFunction } from "@remix-run/node";
import { Container, Stack, Modal} from 'react-bootstrap';

import { Form } from "@remix-run/react"
import { SocialsProvider } from 'remix-auth-socials';

import google_icon from 'icons/google.svg';
import github_icon from 'icons/github.svg';
import facebook_icon from 'icons/facebook.svg';
import discord_icon from 'icons/discord.svg';
import Page from "layouts/page";

export const meta: MetaFunction = () => {
  return [
    { title: "Login" },
    { name: "description", content: "Welcome to Remix!" },

  ];
};

const GoogleButton = ({ provider, label }) => (
  <Form action={`/auth/${provider}`} method="post">
    <button className="btn fs-1"><img src={google_icon} width="50px"/>{label}</button>
  </Form>
);

const GithubButton = ({ provider, label }) => (
  <Form action={`/auth/${provider}`} method="post">
    <button className="btn fs-1"><img src={github_icon}width="50px"/>{label}</button>
  </Form>
);

const FacebookButton = ({ provider, label }) => (
  <Form action={`/auth/${provider}`} method="post">
    <button className="btn fs-1"><img src={facebook_icon}width="50px"/>{label}</button>
  </Form>
);

const DiscordButton = ({ provider, label }) => (
  <Form action={`/auth/${provider}`} method="post">
      <button className="btn fs-1">
      <img src={discord_icon}width="50px"/>{label}
    </button>
  </Form>
);


export function LoginBody(){
  return (
    <Container>
      <Stack>
        <Stack direction="horizontal" className="col justify-content-center align-items-center">
          <DiscordButton provider={SocialsProvider.DISCORD} label="" />
          <GithubButton provider={SocialsProvider.GITHUB} label="" />
        </Stack>
        <Stack direction="horizontal" className="col justify-content-center align-items-center">
          <GoogleButton provider={SocialsProvider.GOOGLE} label="" />
          <FacebookButton provider={SocialsProvider.FACEBOOK} label="" />
        </Stack>
      </Stack>
    </Container>
  );
}

export function LoginModal(props) {
  return (
    <>
      <Modal
        {...props}
        size="sm"
        aria-labelledby="contained-modal-title-vcenter"
        centered
      >
        <Modal.Header closeButton>
          <Modal.Title id="contained-modal-title-vcenter">
            Login: 
          </Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <LoginBody/>
        </Modal.Body>
      </Modal>
    </>
  );
}

export default function Login() {
  return (
    <Page main={
      <LoginBody/>
    }
    />
    )
}
```

The first components defined are our login buttons, you can see they're pretty simple, just a remix form wrapping a button with a label. These are placed in a grid on our page with the component 'Login', notice the export default which makes that the component that will load when routed to /auth/login. The layout for the buttons is defined in LoginBody, a centered two rows of stacks with our login buttons. We also define a LoginModal which we'll add to our login header so that a page navigation isn't required to login. Note that none of these buttons are functional yet, they'll just route to a page that does not yet exist ('auth/$provider'). Let's update our header to have our login nav open the LoginModal, and optionally toggle the nav links depending on whether the user is logged in our not. 

```tsx
// app/layouts/header.tsx
import { Navbar, Nav, Container , Button} from 'react-bootstrap';
import { NavLink, Form} from "@remix-run/react";
import { useState } from 'react';
import { LoginModal } from "routes/auth.login"


export function Auth({ user }){
  const [modalShow, setModalShow] = useState(false);
  return (
    <>
    {!user ? (
      <>
      <Nav.Link className="btn" 
        onClick={() => setModalShow(true)}>
          LogIn
        </Nav.Link>
        <LoginModal show={modalShow} 
          onHide={() => setModalShow(false)} />
      </>
      ) : (
      <Form action="/auth/logout" method="post">
        <button className="btn nav-link">
          Logout 
        </button>
      </Form> )
    }
    </>
  );
}

export function CollapsingNav({ user }){
  return (
    <Navbar.Collapse id="basic-navbar-nav" className="justify-content-end">
      <Nav defaultActiveKey="/" 
      className="justify-content-end">
        <Nav.Link as={NavLink} to="/">Home</Nav.Link>
        <Nav.Link as={NavLink} to="/recipes">Recipes</Nav.Link>
        <Nav.Link as={NavLink} to="/denied">About</Nav.Link>
        <Auth user={user}/>
      </Nav>
    </Navbar.Collapse>
  )
}

export default function Header({ user }) {
  const [modalShow, setModalShow] = useState(false);
  return (
    <Navbar expand='md' bg="dark" data-bs-theme="dark"
      className="Header bg-body-secondary py-0 px-3 mb-2 sticky-top">
      <Container fluid>
        <Navbar.Brand className="Header">MG</Navbar.Brand>
        <Navbar.Toggle aira-controls="basic-navbar-nav" />
        <CollapsingNav user={user}/>
      </Container>
    </Navbar>
  );
}
```

We've added prop 'user' to all the components and one new component to replace the login nav-link, Auth, which will handle both the login-modal and the switching to logout if a user is signed in (if 'user' is not null). 

We're now ready to add the rest of the login logic, as of now we have social login buttons that point to an action that doesn't exist auth/$provider. We're going to separate our action into two parts, the initial action called from the form and a separate loader that will start the login request. This allows us to use the first stage to store the current page into a cookie that we can retrieve when the user returns from the social authentication process. 

```tsx
// app/routes/auth.$provider.tsx
import { ActionArgs, redirect, defer } from "@remix-run/node"
import { authenticator } from 'utils/auth.server';
import { sessionStorage } from 'utils/session.server';


export let action = async ({ request, params }: ActionArgs) => {
  let ref_url = request.headers.get('referer');
  let session = await sessionStorage.getSession(
      request.headers.get('Cookie'));
  session.flash('redirect_url', ref_url);
  let headers = new Headers(
    { "Set-Cookie": await sessionStorage.commitSession(session)});
  return redirect(`/auth/${params.provider}`, {headers: headers});
}

export let loader = ({ request, params }: ActionArgs) => {
  return authenticator.authenticate(params.provider, request); 
}
```

The first action gets the referring url from the incoming request and flashes this into the cookie which is returned with a redirect to the same page (which calls the loader for the page). The loader just calls remix-auth's authentication method with provider coming from the form data. Next, we need to handle the callback from the social provider. This will be where the user returns after the authentication process with a header containing the users credentials.

```tsx
// app/routes/auth.$provider.callback.tsx
import { LoaderArgs } from "@remix-run/node"
import { authenticator } from 'utils/auth.server';
import { sessionStorage } from 'utils/session.server';

export let loader = async ({ request, params }: LoaderArgs) => {
  const session = await sessionStorage.getSession(
    request.headers.get('Cookie'));
  let redirect_url = session.get('redirect_url');
  await sessionStorage.commitSession(session)
  return authenticator.authenticate(params.provider, request, {
    successRedirect: redirect_url,
    failureRedirect: '/denied',
  });

};
```

Now, we make use of the redirect url stored in the cookie session and make another call to authenticate where if successfully logged in a user is directed back to their original page (redirect_url) and if authentication failed, a user is sent to a denied route that at some point we should create with some details on why they arrived there But for now our authentication process is complete. For it to actually work we'll need to register our site and callback location with each social provider we want to authenticate with, e.g. [google's setup guide](https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid). 


### Creating a comment layout

We're going to create a comment layout that will work both in the sidebar and as trailing content in the main body. We'd like the comment to identify a user by name and with an avatar, a date of the comment and a link to the route that the comment addresses, and the comment itself. Lastly, we'll want a simple text-input and submit button for adding new comments.

```tsx
// app/layouts/comments.tsx
import { NavLink, Form, useNavigation, useLocation} from "@remix-run/react";
import { useRef, useEffect } from 'react';
import { Stack } from "react-bootstrap";


export function Comment( { comment } ){
  // Render a single comment
  return (
     <Stack className="border rounded">
      <Stack direction="horizontal" gap={1}>
        <img src={comment.avatar} width="50" referrerPolicy="no-referrer"/>
        <h6> {comment.userName}</h6>
      </Stack>
      <Stack direction="horizontal">
        <div className="ms-0 me-auto">
        <small><small>
          <a href={comment.postSlug}>
            {comment.postName} 
          </a>
        </small></small>
        </div>
        <div className="ms-auto me-0">
        <small><small>
          {(new Date(comment.createdAt)).toLocaleString(
          'en-CA', { hour12: false, timezone: "UTC", 
          dateStyle: "short", timeStyle: "short"})}
        </small></small>
        </div>
      </Stack>
      <hr className="p-0 m-0"/>
        {comment.comment}
    </Stack>
  );
}

export default function Comments({ sidebar }){
  let comments = sidebar.comments;
  let user = sidebar.user;
  let navigation = useNavigation();
  let busy = navigation.state === "submitting";
  let buttonDisable = (busy || !user);
  let formRef = useRef();
  let matches = useLocation();
  console.log(sidebar.frontmatter);

  useEffect(() => {
    if(!busy) {
      formRef.current?.reset();
    }
  },[busy])

  // Create comment fields
  let postName = sidebar.postName;
  let postSlug = sidebar.slug;
  let userName = user.displayName;
  let avatar = user.photos[0].value;

  return (
    <Stack className='p-0 mx-0 mt-1 text-break' gap={2}>
      <h3>Comments</h3>
      <Form ref={formRef} method="post" action={postSlug}>
        <input type="hidden" name="postName" value={postName} />
        <input type="hidden" name="postSlug" value={postSlug} />
        <input type="hidden" name="userName" value={userName} />
        <input type="hidden" name="avatar" value={avatar} />
        <Stack>
          <textarea rows={3} className="d-flex" type="text" name="comment"/>{" "}
          <button disabled={buttonDisable} type="submit">
            {!user ? ("Please log in...") : ("Submit")}</button>
        </Stack>
      </Form>
      {comments.map( (comment) => (
        <Comment comment={comment} key={comment.id}/>
      ) )}
    </Stack>
  );
}
```

The first component, Comment, defines the layout for displaying comments. Meta information is separated from the comment-text by a horizontal rule. We'll use the fields formatted here as a template for the database we'll need to store and recall comments for each post. Note, the FormRef and useEffect are needed to clear the user input upon submission, [These remix tutorials](https://www.youtube.com/watch?v=w2i-9cYxSdc&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6&index=5) explain why this is necessary and outline some general use patterns of forms. 


Aaaaand I'm bored of this. The gist of the notes are here, for the rest you can inspect the complete [git repo here](https://github.com/m-gutierrez/remixApp). Please feel free to comment if you have questions or, more likely, suggestions for how to improve what I've done here. 